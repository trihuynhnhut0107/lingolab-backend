# LingoLab Backend API

A production-ready Express.js backend API with TypeScript, PostgreSQL, TypeORM, and auto-generated Swagger documentation via tsoa.

## ğŸš€ Tech Stack

- **Framework**: Express.js 4.x
- **Language**: TypeScript 5.x
- **Database**: PostgreSQL 15 (Docker)
- **ORM**: TypeORM 0.3.x
- **API Documentation**: Swagger via tsoa
- **Module System**: CommonJS

## ğŸ“‹ Prerequisites

- Node.js (v18 or higher)
- npm or yarn
- Docker & Docker Compose (for PostgreSQL)

## ğŸ› ï¸ Installation

### 1. Install Dependencies

```bash
npm install
```

### 2. Configure Environment Variables

The `.env` file has been created from `.env.example`. Modify if needed:

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=lingolab_db

# Server Configuration
NODE_ENV=development
PORT=3000

# TypeORM Configuration
TYPEORM_SYNCHRONIZE=true
TYPEORM_LOGGING=true
```

âš ï¸ **Important**: Set `TYPEORM_SYNCHRONIZE=false` in production!

### 3. Start PostgreSQL Database

```bash
docker-compose up -d
```

Verify the database is running:

```bash
docker ps
```

You should see `lingolab_postgres` container running.

### 4. Generate Swagger Documentation & Routes

```bash
npm run swagger
```

This generates:
- `src/routes.ts` - Express routes
- `src/swagger.json` - OpenAPI specification

### 5. Start Development Server

```bash
npm run dev
```

The server will start on `http://localhost:3000` with hot-reload enabled.

## ğŸ“¦ Build for Production

```bash
npm run build
npm start
```

## ğŸ”— API Endpoints

### Base URLs
- **API Base**: `http://localhost:3000/api`
- **Health Check**: `http://localhost:3000/health`
- **Swagger Docs**: `http://localhost:3000/docs`

### User Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/users` | Get all users |
| GET | `/api/users/:id` | Get user by ID |
| POST | `/api/users` | Create new user |
| PUT | `/api/users/:id` | Update user |
| DELETE | `/api/users/:id` | Delete user |

### Example Request

**Create User:**
```bash
curl -X POST http://localhost:3000/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "John Doe",
    "email": "john@example.com",
    "bio": "Software developer"
  }'
```

**Get All Users:**
```bash
curl http://localhost:3000/api/users
```

## ğŸ“ Project Structure

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ database.ts          # TypeORM configuration
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â””â”€â”€ UserController.ts    # API controllers with tsoa decorators
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ User.ts              # TypeORM entities
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ UserService.ts       # Business logic layer
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ errorHandler.ts      # Error handling middleware
â”‚   â”œâ”€â”€ routes.ts                # Generated by tsoa
â”‚   â”œâ”€â”€ swagger.json             # Generated by tsoa
â”‚   â””â”€â”€ server.ts                # Express server entry point
â”œâ”€â”€ docker-compose.yml           # PostgreSQL container
â”œâ”€â”€ tsconfig.json                # TypeScript config (CommonJS)
â”œâ”€â”€ tsoa.json                    # tsoa configuration
â”œâ”€â”€ package.json
â”œâ”€â”€ .env                         # Environment variables (local)
â”œâ”€â”€ .env.example                 # Environment variables (template)
â”œâ”€â”€ .gitignore                   # Git ignore rules
â””â”€â”€ README.md                    # Project documentation
```

## ğŸ§ª Available Scripts

| Script | Description |
|--------|-------------|
| `npm run dev` | Start development server with hot-reload |
| `npm run build` | Build TypeScript to JavaScript |
| `npm start` | Run production server |
| `npm run swagger` | Generate Swagger docs and routes |
| `npm run typeorm` | Run TypeORM CLI commands |

## ğŸ”§ TypeScript Configuration

The project uses **CommonJS** module system for Express.js compatibility:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",          // â† Express.js compatible
    "esModuleInterop": true,
    "experimentalDecorators": true, // â† Required for TypeORM & tsoa
    "emitDecoratorMetadata": true   // â† Required for TypeORM
  }
}
```

## ğŸ—ƒï¸ Database Management

### Access PostgreSQL Container

```bash
docker exec -it lingolab_postgres psql -U postgres -d lingolab_db
```

### Stop Database

```bash
docker-compose down
```

### Reset Database (Delete All Data)

```bash
docker-compose down -v
docker-compose up -d
```

## ğŸ—ï¸ Adding New Features

### 1. Create Entity

```typescript
// src/entities/Product.ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity("products")
export class Product {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column()
  name: string;

  @Column("decimal")
  price: number;
}
```

### 2. Create Service

```typescript
// src/services/ProductService.ts
import { Repository } from "typeorm";
import { AppDataSource } from "../config/database";
import { Product } from "../entities/Product";

export class ProductService {
  private productRepository: Repository<Product>;

  constructor() {
    this.productRepository = AppDataSource.getRepository(Product);
  }

  public async getAllProducts(): Promise<Product[]> {
    return await this.productRepository.find();
  }
}
```

### 3. Create Controller

```typescript
// src/controllers/ProductController.ts
import { Controller, Get, Route, Tags } from "tsoa";
import { ProductService } from "../services/ProductService";

@Route("products")
@Tags("Products")
export class ProductController extends Controller {
  private productService: ProductService;

  constructor() {
    super();
    this.productService = new ProductService();
  }

  @Get()
  public async getProducts() {
    return await this.productService.getAllProducts();
  }
}
```

### 4. Register Entity in Database Config

```typescript
// src/config/database.ts
import { Product } from "../entities/Product";

export const AppDataSource = new DataSource({
  // ...
  entities: [User, Product], // â† Add new entity
});
```

### 5. Regenerate Routes

```bash
npm run swagger
```

## ğŸ—ï¸ Architecture Overview

### Layered Architecture

This project follows a three-layer architecture pattern for clean code organization:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Controllers       â”‚  (HTTP Handlers)
â”‚   (tsoa decorators) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Services        â”‚  (Business Logic)
â”‚   (TypeORM repos)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Entities       â”‚  (Data Models)
â”‚   (TypeORM DTOs)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    PostgreSQL       â”‚  (Data Persistence)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Layer Responsibilities:**
- **Controllers**: Handle HTTP requests/responses, validation, routing
- **Services**: Implement business logic, database queries, transformations
- **Entities**: Define data models, database schema, relationships
- **Middleware**: Cross-cutting concerns (error handling, logging, authentication)

### Data Flow

```
HTTP Request
    â†“
Express Middleware
    â†“
tsoa Route Handler
    â†“
UserController
    â†“
UserService
    â†“
TypeORM Repository
    â†“
PostgreSQL
    â†“
Response (JSON)
```

## ğŸ”„ Development Workflow

### Adding a New Entity

1. **Create the Entity** (e.g., `src/entities/Lesson.ts`):
   - Use TypeORM decorators
   - Define columns with types and constraints
   - Add timestamps if needed

2. **Create the Service** (e.g., `src/services/LessonService.ts`):
   - Implement CRUD operations
   - Add business logic
   - Use TypeORM repositories

3. **Create the Controller** (e.g., `src/controllers/LessonController.ts`):
   - Define API endpoints with tsoa decorators
   - Handle request validation
   - Return appropriate status codes

4. **Register the Entity**:
   - Add to `entities` array in `src/config/database.ts`

5. **Generate Routes**:
   ```bash
   npm run swagger
   ```

6. **Test the Endpoints**:
   - Start server: `npm run dev`
   - Visit Swagger: `http://localhost:3000/docs`
   - Test endpoints in Swagger UI

## ğŸ›¡ï¸ Error Handling

The project implements centralized error handling via Express middleware:

```typescript
// src/middleware/errorHandler.ts
export const errorHandler = (err, req, res, next) => {
  const status = err.status || 500;
  const message = err.message || "Internal Server Error";

  res.status(status).json({
    message,
    status,
    details: process.env.NODE_ENV === "development" ? err.details : undefined
  });
};
```

**Error Response Format:**
```json
{
  "message": "User not found",
  "status": 404,
  "details": "No user with ID: abc123"
}
```

## ğŸ“ Best Practices

### TypeScript

- âœ… Use strict mode (`strict: true` in tsconfig.json)
- âœ… Type all function parameters and return values
- âœ… Use interfaces for data contracts
- âœ… Use definite assignment assertions (!) for ORM properties

### Database

- âœ… Use transactions for multi-step operations
- âœ… Add indexes for frequently queried columns
- âœ… Use migrations for schema changes (set up migrations later)
- âœ… Keep synchronize false in production

### API Design

- âœ… Use RESTful conventions (GET, POST, PUT, DELETE)
- âœ… Use correct HTTP status codes
- âœ… Return consistent response formats
- âœ… Document endpoints with tsoa decorators

### Error Handling

- âœ… Use try-catch for async operations
- âœ… Log errors with context
- âœ… Return meaningful error messages
- âœ… Use appropriate HTTP status codes

## ğŸ› Troubleshooting

### Database Connection Failed
```bash
# Check if Docker is running
docker ps

# Check PostgreSQL logs
docker logs lingolab_postgres

# Verify credentials in .env match docker-compose.yml
cat .env | grep DB_

# Restart the database
docker-compose restart postgres
```

### Swagger Not Available
```bash
# Generate documentation
npm run swagger

# Check if swagger.json was created
ls src/swagger.json

# Run build to see compilation errors
npm run build
```

### TypeScript Compilation Errors
```bash
# Verify decorators are enabled
grep experimentalDecorators tsconfig.json

# See detailed error messages
npm run build

# Reinstall dependencies
rm -rf node_modules package-lock.json
npm install
```

### Port Already in Use
```bash
# Find process using port 3000
lsof -i :3000

# Kill the process
kill -9 <PID>

# Or kill all node processes
pkill -f node
```

### Database Sync Issues
```bash
# Reset database completely (âš ï¸ WARNING: Deletes all data)
docker-compose down -v
docker-compose up -d

# Wait for database to be ready
docker exec lingolab_postgres pg_isready -U postgres
```

## ğŸ” Debugging Tips

### Enable Database Logging
```env
TYPEORM_LOGGING=true
```

### Use PostgreSQL CLI
```bash
# Connect to database
docker exec -it lingolab_postgres psql -U postgres -d lingolab_db

# List tables
\dt

# Show table schema
\d users

# Run custom query
SELECT * FROM users;

# Exit
\q
```

### Check Generated Routes
```bash
# View auto-generated routes file
cat src/routes.ts

# View OpenAPI specification
cat src/swagger.json
```

### VS Code Debugging
Add to `.vscode/launch.json`:
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "program": "${workspaceFolder}/node_modules/.bin/ts-node",
      "args": ["src/server.ts"],
      "console": "integratedTerminal"
    }
  ]
}
```

## ğŸ“š Learning Resources

- [Express.js Documentation](https://expressjs.com/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [TypeORM Documentation](https://typeorm.io/)
- [tsoa Documentation](https://tsoa-community.github.io/docs/)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [RESTful API Design Best Practices](https://restfulapi.net/)

## ğŸš€ Next Steps

1. **Authentication**: Add JWT-based authentication
2. **Validation**: Add input validation with decorators
3. **Testing**: Set up Jest for unit and integration tests
4. **Logging**: Implement structured logging
5. **Caching**: Add Redis for performance optimization
6. **Migrations**: Set up TypeORM migrations for schema management
7. **Deployment**: Containerize and deploy to production

## ğŸ¤ Contributing

When adding new features:

1. Create a new branch: `git checkout -b feature/your-feature`
2. Make changes following the architecture pattern
3. Test locally: `npm run dev`
4. Build successfully: `npm run build`
5. Commit with clear messages: `git commit -m "feat: add new feature"`
6. Push and create a pull request

## ğŸ“ License

ISC

## ğŸ‘¥ Author

LingoLab Team

---

**Need help?** Check the [Swagger documentation](http://localhost:3000/docs) for detailed API information.
